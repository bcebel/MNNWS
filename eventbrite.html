<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Austin Events Calendar</title>
<!-- FullCalendar CSS -->
<link href="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.css" rel="stylesheet">
<style>
body {
font-family: Arial, sans-serif;
max-width: 1000px;
margin: 20px auto;
padding: 0 10px;
}
#calendar {
margin-top: 20px;
}
.attribution {
font-size: 0.8em;
color: #555;
margin-top: 10px;
}
.fc-event-title {
cursor: pointer;
}
.error {
color: red;
text-align: center;
}
#search-container {
margin-bottom: 20px;
text-align: center;
}
#city-input {
padding: 10px;
width: 300px;
}
#search-btn {
padding: 10px 20px;
}
</style>
</head>
<body>
<h1>Events Calendar</h1>
<div id="search-container">
  <input type="text" id="city-input" placeholder="Enter city (e.g., Austin, TX)">
  <button id="search-btn">Search</button>
</div>
<div id="calendar"></div>
<p class="attribution">Events sourced from <a href="https://www.eventbrite.com" target="_blank">Eventbrite</a>.</p>

<!-- FullCalendar JS -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js"></script>
<script>
// Initialize FullCalendar
document.addEventListener('DOMContentLoaded', function() {
  const calendarEl = document.getElementById('calendar');
  const cityInput = document.getElementById('city-input');
  const searchBtn = document.getElementById('search-btn');
  let calendar;

  async function fetchEvents(info, successCallback, failureCallback) {
    const city = cityInput.value || 'Austin, TX';
    try {
      // Eventbrite API call
      // WARNING: For production environments, it is strongly recommended to use a server-side proxy
      // to handle API requests. Exposing API keys, even public ones, on the client-side can be a security risk.
      const response = await fetch(
        `https://www.eventbriteapi.com/v3/events/search/?location.address=${city}&location.within=10mi&start_date.range_start=${info.startStr}&start_date.range_end=${info.endStr}&sort_by=date`,
        {
          headers: {
            Authorization: 'Bearer 7HL7WDXN2HA66ZZL54E2', // Public API Key
          },
        }
      );
      if (!response.ok) throw new Error('API request failed');
      const data = await response.json();

      // Transform Eventbrite data into FullCalendar events
      const events = data.events.map(event => ({
        title: event.name.text,
        start: event.start.local, // ISO8601 date (e.g., 2025-10-01T19:00:00)
        url: event.url, // Links to Eventbrite event page
        extendedProps: {
          description: event.description.text?.substring(0, 100) + '...' || 'No description',
          source: 'Eventbrite',
        }
      }));

      successCallback(events);
    } catch (error) {
      console.error('Error fetching events:', error);
      document.getElementById('calendar').innerHTML = '<p class="error">Failed to load events. Please try again later.</p>';
      failureCallback(error);
    }
  }

  calendar = new FullCalendar.Calendar(calendarEl, {
    initialView: 'dayGridMonth', // Monthly view
    events: fetchEvents,
    eventClick: function(info) {
      // Open event URL in new tab
      info.jsEvent.preventDefault();
      if (info.event.url) {
        window.open(info.event.url, '_blank');
      }
    },
    eventContent: function(info) {
      // Customize event display with attribution
      return {
        html: `
          <div>
            <b>${info.event.title}</b><br>
            <small>${info.event.extendedProps.description}</small><br>
            <small>Source: ${info.event.extendedProps.source}</small>
          </div>
        `
      };
    }
  });

  calendar.render();

  searchBtn.addEventListener('click', () => {
    calendar.refetchEvents();
  });
});
</script>
</body>
</html>
